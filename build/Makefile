################################################################################
# This is the Makefile that is used to actually build your code. When you run  #
# "make" in the root directory for this project, a "build" directory gets      #
# created and this file is added there as the Makefile. Parts of this Makefile #
# are derived from one generated by the automake utility. Other parts were     #
# derived from the Pintos OS source code Makefiles.                            #
################################################################################

# Since this file gets copied into the build directory, we will
# need to do ../ to get back to the source code directory

SRCDIR = ..

# "all" is a special command directive.  If you run "make" from
# the command line, it will actually invoke "make all".  This, in
# turn, will start a chain reaction that causes the objects to be
# compiled, then linked into an executable at the end. To be
# specific, "make all" depends on completing the "all-prog"
# directive, which is defined below. As you can see there, "all-prog"
# depends on $(PROGRAMS), which is an alias for $(bin_PROGRAMS),
# which is the last directive in this file. You can see that one
# depends on $(OBJECTS), which are the individually compiled object
# files (one is generated for each .c source file). Once all of
# those are compiled, we can link them together to build our
# program.
all: all-prog

include ../Make.config
include ../Make.vars
include ../tests/Make.tests
include ../Make.src

# Specify the name of your executable program here. Notice that the
# $(EXEEXT) is specified in Make.config as appropriate for your
# platform. If this were a Windows machine, it would be .exe
# Note that it is important to have no spaces or punctuation between
# your program name $(EXENAME) and the $(EXEEXT)
bin_PROGRAMS = $(EXENAME)$(EXEEXT)

# If the project had multiple subdirectories (instead of just the
# single "project" subdirectory we are using), SOURCES would be the
# concatenation of all the files named in the source code listing
# above. Objects would be the same, but replace .c with .o for each
# file.
SOURCES = $(foreach dir,$(SRC_SUBDIRS),$($(dir)_SRC))
OBJECTS = $(patsubst %.c,%.o,$(SOURCES))
PROGRAMS = $(bin_PROGRAMS)

all-prog: Makefile $(PROGRAMS)
	make clean.test

# Executing "make clean" will delete the executable and all object
# files.  This creates a nice, clean software package ready for
# compilation.
clean::
	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
	-test -z "$(OBJECTS)" || rm -f $(OBJECTS)

Makefile: $(SRCDIR)/Makefile.build
	cp $< $@

# Specify how to build the final executable. This depends on first
# building all the objects. Once they are all compiled, we link
# them together into a single executable.
$(bin_PROGRAMS): $(OBJECTS)
	@rm -f $(bin_PROGRAMS)
	$(LINK) $(OBJECTS)
